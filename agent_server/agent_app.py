"""
agent_app.py
FastAPI application exposing the agent's entrypoints.

Endpoints:
  - POST /ask: main entry for user messages; returns a reply generated by the agent.
  - POST /webhook/bank: called by the banking server when an OTP is sent or verified.

The webhook uses a shared `SERVICE_TOKEN` for authentication.  When an OTP is sent, the
text is inserted directly into the chat history so the user sees it.  When an OTP
is verified, the resulting access token is stored and any pending action is resumed.
"""

from fastapi import FastAPI, Request, HTTPException
from pydantic import BaseModel
from typing import Optional
import os

from service import handle_ask, PENDING_ACTIONS, synthesize_reply
from memory_manager import get_chat_history
from bank_tool import save_token, get_account_summary as bt_get_account_summary
from config import SERVICE_TOKEN


app = FastAPI(title="Agent: Gemini planner + Ollama answer")


class AskRequest(BaseModel):
    phone_num: str
    message: str
    account_id: Optional[str] = None
    bank_name: Optional[str] = "mock"


@app.post("/ask")
def ask(req: AskRequest):
    """Endpoint for handling user messages."""
    user_id = req.account_id or req.phone_num
    return handle_ask(
        user_id=user_id,
        prompt=req.message,
        account_id=req.account_id,
        bank_name=req.bank_name,
        phone_num=req.phone_num
    )


@app.post("/webhook/bank")
async def bank_webhook(req: Request):
    """
    Banking server posts JSON events here:
      {"event": "otp_sent"|"otp_verified"|"message", "phone": "...", "bank": "...", "payload": {...}}
    The Authorization header must be `Bearer <SERVICE_TOKEN>`.
    """
    # Authenticate the webhook call
    auth = req.headers.get("authorization", "").replace("Bearer ", "").strip()
    if auth != SERVICE_TOKEN:
        raise HTTPException(status_code=401, detail="unauthorized")
    body = await req.json()
    event = body.get("event")
    phone = body.get("phone")
    bank = body.get("bank", "mock")
    payload = body.get("payload", {})
    user_id = phone  # Map phone to user session id
    chat_history = get_chat_history(user_id)

    if event == "otp_sent":
        # Show OTP text directly in chat (no real SMS needed)
        text = payload.get("text", "OTP đã gửi.")
        chat_history.add_ai_message(f"[Ngân hàng {bank}] {text}")
        return {"ok": True}
    
    if event == "otp_verified":
        token = payload.get("access_token")
        ttl = int(payload.get("ttl", 600))
        account_id = payload.get("account_id")
        if token:
            # LƯU ĐÚNG CHỮ KÝ
            save_token(phone, bank, account_id, token, ttl_seconds=ttl)
        # Try to resume any pending action: get balance after OTP
        pending = PENDING_ACTIONS.get(user_id)
        if pending:
            try:
                safe = bt_get_account_summary(account_id=pending.get("account_id"), phone_num=phone, bank_name=bank)
                context = "\n".join([f"{m.type}: {m.content}" for m in chat_history.messages])
                ans = synthesize_reply(
                    "Tự động tiếp tục sau khi OTP xác thực",
                    "get_account_summary",
                    tool_data=safe,
                    context=context
                )
                chat_history.add_ai_message(ans)
                PENDING_ACTIONS.pop(user_id, None)
                return {"ok": True, "resumed": True}
            except Exception as e:
                chat_history.add_ai_message(f"[Ngân hàng {bank}] OTP đã xác thực, nhưng xảy ra lỗi: {e}")
                return {"ok": True, "resumed": False, "error": str(e)}
        # If no pending action, simply acknowledge
        chat_history.add_ai_message(f"[Ngân hàng {bank}] OTP đã xác thực.")
        return {"ok": True, "resumed": False}
    if event == "message":
        text = payload.get("text", "")
        if text:
            chat_history.add_ai_message(f"[{bank}] {text}")
        return {"ok": True}
    return {"ok": False, "message": "unknown event"}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run("agent_app:app", host="0.0.0.0", port=int(os.getenv("PORT", 8000)), reload=True)